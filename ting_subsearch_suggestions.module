<?php

/**
 * @file
 * Ting subsearch using suggestion services: Opensuggestion and KPI-Webtrekk.
 */

use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\Exception\ClientException as GuzzleClientException;
use Ting\Search\NullSearchResult;

module_load_include('inc', 'ting_subsearch_suggestions', 'ting_subsearch_suggestions.admin');

// The minimum time between imports during cron runs.
define('TING_SUBSEARCH_SUGGESTIONS_WEEKLY_CRON', 604800);

// Number of rows we inspect in each import batch.
define('TING_SUBSEARCH_SUGGESTIONS_IMPORT_BATCH_SIZE', 100000);

// The maximum number of rows to insert in one transaction during CSV-import.
define('TING_SUBSEARCH_SUGGESTIONS_MULTI_INSERT_LIMIT', 10000);

// The Max number of chars in suggestions.
define('TING_SUBSEARCH_SUGGESTIONS_SUGGESTION_LIMIT', 150);

/**
 * Implements hook_menu().
 */
function ting_subsearch_suggestions_menu() {

  $items['admin/config/ting/subsearch-suggestions'] = [
    'title' => 'Ting subsearch suggestions',
    'description' => 'Administer Ting subsearch suggestions',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['ting_subsearch_suggestions_import_form'],
    'access arguments' => ['administer site configuration'],
    'file' => 'ting_subsearch_suggestions.admin.inc',
  ];

  $items['admin/config/ting/subsearch-suggestions/import'] = [
    'title' => 'Import',
    'description' => 'Import newest data from feed and check status',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  ];

  $items['admin/config/ting/subsearch-suggestions/import/confirm-reset'] = [
    'title' => 'Confirm reset',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['ting_subsearch_suggestions_reset_index_confirm_form'],
    'access arguments' => ['administer site configuration'],
    'file' => 'ting_subsearch_suggestions.admin.inc',
  ];

  $items['subsearch_suggestions'] = [
    'title' => 'Subsearch Suggestions',
    'description' => 'AJAXify request for subsearch suggestions',
    'page callback' => 'ting_subsearch_suggestions_ajax_callback',
    'access callback' => TRUE,
  ];

  return $items;
}

/**
 * Custom AJAX menu callback.
 */
function ting_subsearch_suggestions_ajax_callback() {
  $message = '';
  if (!empty($_POST)) {
    $keys = $_POST['keys'];
    $conditions = $_POST['conditions'];
    $results = unserialize($_POST['results']);

    $message = ting_subsearch_suggestions_get_message($keys, $conditions, $results);
  }

  drupal_json_output($message);
  drupal_exit();
}

/**
 * Generation of suggestion message.
 *
 * @param $keys
 * @param $conditions
 * @param $results
 *
 * @return string|void
 * @throws \TingClientException
 * @throws \Ting\Search\SearchProviderException
 */
function ting_subsearch_suggestions_get_message($keys, $conditions, $results) {
  if ($results instanceof NullSearchResult) {
    return;
  }

  $num_total_objects = $results->getNumTotalObjects();

  $message = '';

  // When a zero-hit search is executed and we're able to match "correct"
  // keys, a new search is done with the "correct" keys.
  // Then use the query-parameter original-keys to display what was done to
  // the visitor.
  $parameters = drupal_get_query_parameters();

  if (isset($parameters['original-search'])) {
    $msg = t('See results for "!keys", the search for "!original-keys" returned 0 hits.', [
      '!original-keys' => $parameters['original-search'],
      '!keys' => $keys,
    ]);

    $message = '<div id="subsearch-suggestions-first">' . $msg . '</div>';
  }

  if ($num_total_objects == 0) {
    // Find suggestions for "correct" search phrase.
    $suggestion = ting_subsearch_common_suggested_keys($keys, 'ting_subsearch_suggestions_suggest_keys');

    if (strpos($suggestion, 'ting_search:') !== FALSE) {
      $clear_suggestion = explode(':', $suggestion);
      $suggestion = $clear_suggestion[1];
    }

    if ($suggestion) {
      // Do secondary search for "correct" keys.
      $secondary_result = ting_subsearch_common_do_secondary_search($suggestion);
      // Only redirect to "correct" keys search if it has a positive result.
      if (!empty($secondary_result) && $secondary_result->numTotalObjects > 0) {
        $additional_query = [
          'original-search' => $keys,
        ];
        $params['query'] = $additional_query;
        global $base_url;
        $url = $base_url . '/search/ting/' . strtolower($suggestion) . '?' . drupal_http_build_query($params['query']);

        header('Location: ' . $url, TRUE, 301);
      }
    }
  }
  elseif ($num_total_objects <= variable_get("ting_subsearch_suggestions_trigger_limit", 5)) {
    $suggestion = ting_subsearch_common_suggested_keys($keys, 'ting_subsearch_suggestions_suggest_keys');
    $suggestion = trim($suggestion);

    if ($service == 'kpi') {
      if (strpos($suggestion, 'ting_search:') !== FALSE) {
        $clear_suggestion = explode(':', $suggestion);
        $suggestion = $clear_suggestion[1];
      }
    }
    if ($suggestion) {
      // Do additional search.
      $suggested_result = ting_subsearch_common_do_secondary_search($suggestion);
      $sug_total_number = $suggested_result->numTotalObjects;
      if (!empty($suggested_result) && $sug_total_number >= variable_get("ting_subsearch_suggestions_message_limit", 10)) {
        $ratio = $sug_total_number / $num_total_objects;

        if ($ratio > variable_get('ting_subsearch_suggestions_ps_factor')) {
          $options = [];
          if (module_exists('ting_field_search')) {
            $profile = ting_field_search_get_active_profile();
            if ($profile) {
              $options['query'] = ['profile' => $profile->name];
            }
          }

          if (!empty(variable_get("ting_subsearch_{$service}_additional_url_params_inlimit", "")) && !empty($options)) {
            $options['query'] += ting_subsearch_common_query_params(variable_get("ting_subsearch_{$service}_additional_url_params_inlimit", ""));
          }
          else {
            if (empty($options)) {
              $options['query'] = ting_subsearch_common_query_params(variable_get("ting_subsearch_{$service}_additional_url_params_inlimit", ""));
            }
          }

          // Set message!
          $msg = t('Search for <strong>"!suggested-key"</strong> (!suggested-num-results)', [
            '!suggested-key' => strtolower($suggestion),
            '!suggested-num-results' => $suggested_result->numTotalObjects,
          ]);

          $wrapper = '<div id="subsearch-suggestions-second">' . $msg . '</div>';

          $url = url('/search/ting/' . strtolower($suggestion), [
            'query' => $options['query'],
            'absolute' => TRUE,
          ]);

          $message = l($wrapper, $url, [
            'html' => TRUE,
            'absolute' => TRUE,
            'attributes' => ['target' => 'blank'],
          ]);
        }
      }
    }
  }

  return $message;
}

/**
 * Implements hook_ting_search_results_prefix().
 */
function ting_subsearch_suggestions_ting_search_results_prefix($keys, $conditions, $results) {
  if ($results->getNumTotalObjects() != 0) {
    drupal_add_js(
      [
        'subsearch_suggestions' => [
          'keys' => $keys,
          'conditions' => $conditions,
          'results' => serialize($results),
        ],
      ],
      'setting'
    );

    drupal_add_js(drupal_get_path('module', 'ting_subsearch_suggestions') . '/js/subsearch_suggestions.js', [
      'type' => 'file',
      'scope' => 'footer',
    ]);
  }
  else {
    ting_subsearch_suggestions_get_message($keys, $conditions, $results);
  }
}

/**
 * Find the best suitable suggestion for the given keys.
 *
 * @param string $keys
 *   The original keys that you want to find suggestion for.
 *
 * @return string
 *   The suggestion or FALSE if it was not possible to find a suggestion within
 *   the configured constraints.
 *
 * @throws Exception
 */
function ting_subsearch_suggestions_suggest_keys($keys) {
  // Build expected query object for provider hook.
  // See: opensearch_search_autocomplete_suggestions().
  $query = [];
  $query['q'] = $keys;
  $query['type'] = 'all';
  $suggestions= ding_provider_invoke('search', 'autocomplete_suggestions', $query);

  $result = array_reduce($suggestions, function($carry, $suggestion) use ($keys) {
    $candidate = '';
    foreach (explode(' ', $suggestion) as $word) {
      $candidate .= $word;

      // Move along if the candidate has grown over char limit.
      if (drupal_strlen($candidate) > TING_SUBSEARCH_SUGGESTIONS_SUGGESTION_LIMIT) {
        return $carry;
      }

      $distance = ting_subsearch_suggestions_levenshtein($keys, $candidate);

      // If distance gets to 0 it means the suggestions is the same as the user
      // search. We only look for searches close to the user search so skip it.
      if ($distance == 0) {
        return $carry;
      }

      if ($distance <= variable_get('ting_subsearch_suggestions_distance', 3)) {
        if (!isset($carry) || ($carry['distance'] > $distance)) {
          $carry['distance'] = $distance;
          $carry['q'] = $candidate;
        }
      }

      $candidate .= ' ';
    }
    return $carry;
  });

  if (isset($result)) {
    return $result['q'];
  }
  return FALSE;
}

/**
 * Wrapper around PHP's levenshtein that handles multibyte encodings correctly.
 *
 * PHP's levenshtein function processes each byte of the input string
 * individually which can give incorrect results in some cases. E.g. the
 * distance from "ol" to "Ã¸l" would be 2.
 *
 * This wrapper uses an approach where non-ascii characters are remapped to
 * the range [128-255] in order of appearance. Thus it supports up to 128
 * different multibyte code points max over the whole set of strings used in the
 * request and sharing this encoding.
 *
 * Based on: https://stackoverflow.com/a/26271822.
 */
function ting_subsearch_suggestions_levenshtein($str1, $str2) {
  $str1 = _ting_subsearch_suggestions_utf8_to_ascii($str1);
  $str2 = _ting_subsearch_suggestions_utf8_to_ascii($str2);
  return levenshtein($str1, $str2);
}

/**
 * Convert an UTF-8 encoded string to a single-byte string for levenshtein.
 */
function _ting_subsearch_suggestions_utf8_to_ascii($str) {
  $ascii_strings = &drupal_static(__FUNCTION__);
  // Since we remember string we need to ensure we get consistent mapping
  // between calls in a request.
  $map = &drupal_static(__FUNCTION__);

  if (!isset($ascii_strings[$str])) {
    // find all multibyte characters (cf. utf-8 encoding specs)
    $matches = array();
    if (!preg_match_all('/[\xC0-\xF7][\x80-\xBF]+/', $str, $matches)) {
      return $str; // plain ascii string
    }

    // update the encoding map with the characters not already met
    foreach ($matches[0] as $mbc)
      if (!isset($map[$mbc])) {
        $map[$mbc] = chr(128 + count($map));
      }

    // finally remap non-ascii characters
    $ascii_strings[$str] = strtr($str, $map);
  }

  return $ascii_strings[$str];
}
